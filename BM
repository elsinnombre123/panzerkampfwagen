import pandas as pd
import datetime as dt
from abc_quant_internal.tsdb import TSDBSymbol, MDAPISymbol, TSDB

def get_spot_data(cross, start, end):
    # Ensure start and end are of the same date type (dt.date)
    if isinstance(start, dt.datetime):
        start = start.date()
    if isinstance(end, dt.datetime):
        end = end.date()
    
    # Fetches data using your defined method
    data_series = TSDB.get_data(cross, start=start, end=end)
    # Convert to DataFrame
    df = pd.DataFrame(data_series, columns=['spot'])
    df.index = pd.to_datetime(df.index)  # Ensure index is datetime
    df.index.name = 'date'
    return df

def calculate_rolling_returns(df, window_size):
    # Calculate rolling returns as a percentage change over the defined window
    df['rolling_return'] = df['spot'].pct_change(periods=window_size) * 100
    return df

def find_top_non_overlapping_moves(df, window_size, num_moves, direction):
    df['highlight'] = 0  # Initialize highlight column
    selected_moves = []

    # Filter based on direction and sort moves
    if direction == 'Up':
        sorted_moves = df.sort_values(by='rolling_return', ascending=False).dropna(subset=['rolling_return'])
    elif direction == 'Down':
        sorted_moves = df.sort_values(by='rolling_return', ascending=True).dropna(subset=['rolling_return'])
    else:
        raise ValueError("Invalid direction. Use 'Up' or 'Down'.")

    for idx in sorted_moves.index:
        # Check if we already have the required number of moves
        if len(selected_moves) >= num_moves:
            break

        # Define the window for this move
        start_idx = idx - pd.Timedelta(days=window_size - 1)
        end_idx = idx

        # Check if this window overlaps with any previously selected windows
        overlap = False
        for move in selected_moves:
            move_start, move_end = move[0], move[1]
            if not (end_idx < move_start or start_idx > move_end):
                overlap = True
                break

        # If no overlap, select this move
        if not overlap:
            df.loc[start_idx:end_idx, 'highlight'] = 1
            selected_moves.append((start_idx, end_idx, df.loc[idx, 'rolling_return']))

    return df, selected_moves

def main(cross='wmeur', end_date=dt.date.today(), history='10y', num_moves=10, window='1m', direction='Up'):
    # Calculate start date based on the history parameter
    if history.endswith('y'):
        years = int(history[:-1])
        start_date = end_date - dt.timedelta(days=years * 365)
    else:
        raise ValueError("Unsupported history format. Use 'Xy' for years.")

    # Fetch data
    df = get_spot_data(cross, start_date, end_date)

    # Define window size in days (1m = 21 trading days, 1w = 5 trading days)
    window_size = 21 if window == '1m' else 5 if window == '1w' else int(window[:-1])
    
    # Calculate rolling returns
    df = calculate_rolling_returns(df, window_size)

    # Find top non-overlapping moves
    df, selected_moves = find_top_non_overlapping_moves(df, window_size, num_moves, direction)

    # Ensure we return only relevant columns for visualization
    return df[['spot', 'rolling_return', 'highlight']], selected_moves

# Parameters you can define
cross = 'wmeur'  # Asset ticker
end_date = dt.date.today()  # Default end date is today
history = '10y'  # Start date is 10 years before the end date
number_of_biggest_moves = 10  # Number of largest moves to find
window = '1m'  # Defines the return period (e.g., '1m' for 21 days)
direction = 'Up'  # 'Up' for positive moves, 'Down' for negative moves

# Example usage with parameters
df_result, selected_moves = main(cross=cross, end_date=end_date, history=history, num_moves=number_of_biggest_moves, window=window, direction=direction)
print(df_result.head())  # Display the first few rows of the result

---

import matplotlib.pyplot as plt

def plot_highlighted_spot(df):
    # Ensure 'highlight' column is present
    if 'highlight' not in df.columns:
        raise ValueError("DataFrame does not contain a 'highlight' column.")

    plt.figure(figsize=(12, 6))
    plt.plot(df.index, df['spot'], label='Spot Price', color='blue')
    
    # Highlight periods with the 'highlight' column set to 1
    highlighted = df[df['highlight'] == 1]
    plt.fill_between(highlighted.index, df['spot'].min(), df['spot'].max(), 
                     where=highlighted['highlight'] == 1, color='orange', alpha=0.3, label='Highlighted Periods')

    plt.title('Spot Price with Highlighted Periods')
    plt.xlabel('Date')
    plt.ylabel('Spot Price')
    plt.legend()
    plt.grid(True)
    plt.show()

# Call the function to plot
plot_highlighted_spot(df_result)

