import pandas as pd
import datetime as dt
from abc_quant_internal.tsdb import TSDBSymbol, MDAPISymbol, TSDB

def get_spot_data(cross, start, end):
    # Ensure start and end are of the same date type (dt.date)
    if isinstance(start, dt.datetime):
        start = start.date()
    if isinstance(end, dt.datetime):
        end = end.date()
    
    # Fetches data using your defined method
    data_series = TSDB.get_data(cross, start=start, end=end)
    # Convert to DataFrame
    df = pd.DataFrame(data_series, columns=['spot'])
    df.index = pd.to_datetime(df.index)  # Ensure index is datetime
    df.index.name = 'date'
    return df

def calculate_rolling_returns(df, window_size):
    # Calculate rolling returns as a percentage change over the defined window
    df['rolling_return'] = df['spot'].pct_change(periods=window_size) * 100
    return df

def find_top_non_overlapping_moves(df, window_size, num_moves, direction):
    df['highlight'] = 0  # Initialize highlight column
    selected_moves = []

    # Filter based on direction and sort moves
    if direction == 'Up':
        sorted_moves = df.sort_values(by='rolling_return', ascending=False).dropna(subset=['rolling_return'])
    elif direction == 'Down':
        sorted_moves = df.sort_values(by='rolling_return', ascending=True).dropna(subset=['rolling_return'])
    else:
        raise ValueError("Invalid direction. Use 'Up' or 'Down'.")

    for idx in sorted_moves.index:
        # Check if we already have the required number of moves
        if len(selected_moves) >= num_moves:
            break

        # Define the window for this move
        start_idx = idx - pd.Timedelta(days=window_size - 1)
        end_idx = idx

        # Check if this window overlaps with any previously selected windows
        overlap = False
        for move in selected_moves:
            move_start, move_end = move[0], move[1]
            if not (end_idx < move_start or start_idx > move_end):
                overlap = True
                break

        # If no overlap, select this move
        if not overlap:
            df.loc[start_idx:end_idx, 'highlight'] = 1
            selected_moves.append((start_idx, end_idx, df.loc[idx, 'rolling_return']))

    return df, selected_moves

def main(cross='wmeur', end_date=dt.date.today(), history='10y', num_moves=10, window='1m', direction='Up'):
    # Calculate start date based on the history parameter
    if history.endswith('y'):
        years = int(history[:-1])
        start_date = end_date - dt.timedelta(days=years * 365)
    else:
        raise ValueError("Unsupported history format. Use 'Xy' for years.")

    # Fetch data
    df = get_spot_data(cross, start_date, end_date)

    # Define window size in days (1m = 21 trading days, 1w = 5 trading days)
    window_size = 21 if window == '1m' else 5 if window == '1w' else int(window[:-1])
    
    # Calculate rolling returns
    df = calculate_rolling_returns(df, window_size)

    # Find top non-overlapping moves
    df, selected_moves = find_top_non_overlapping_moves(df, window_size, num_moves, direction)

    # Ensure we return only relevant columns for visualization
    return df[['spot', 'rolling_return', 'highlight']], selected_moves

# Parameters you can define
cross = 'wmeur'  # Asset ticker
end_date = dt.date.today()  # Default end date is today
history = '10y'  # Start date is 10 years before the end date
number_of_biggest_moves = 10  # Number of largest moves to find
window = '1m'  # Defines the return period (e.g., '1m' for 21 days)
direction = 'Up'  # 'Up' for positive moves, 'Down' for negative moves

# Example usage with parameters
df_result, selected_moves = main(cross=cross, end_date=end_date, history=history, num_moves=number_of_biggest_moves, window=window, direction=direction)
print(df_result.head())  # Display the first few rows of the result

---

import plotly.graph_objs as go

def plotly_highlighted_spot(df):
    # Ensure 'highlight' column is present
    if 'highlight' not in df.columns:
        raise ValueError("DataFrame does not contain a 'highlight' column.")

    # Base spot line plot
    spot_trace = go.Scatter(
        x=df.index,
        y=df['spot'],
        mode='lines',
        name='Spot Price',
        line=dict(color='blue')
    )

    # Highlighted periods as vertical rectangles
    highlighted_periods = df[df['highlight'] == 1]
    shapes = []
    for start in highlighted_periods.index:
        end = start + pd.Timedelta(days=20)  # Covering a 21-day window
        shapes.append(
            dict(
                type="rect",
                xref="x",
                yref="paper",
                x0=start,
                x1=end,
                y0=0,
                y1=1,
                fillcolor="orange",
                opacity=0.3,
                layer="below",
                line_width=0,
            )
        )

    layout = go.Layout(
        title="Spot Price with Highlighted Periods",
        xaxis_title="Date",
        yaxis_title="Spot Price",
        shapes=shapes,
        showlegend=True
    )

    fig = go.Figure(data=[spot_trace], layout=layout)
    fig.show()

# Call the function to plot
plotly_highlighted_spot(df_result)

