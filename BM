import pandas as pd
import datetime as dt
from enum import Enum
from typing import Union
from abc_quant_internal.tsdb import TSDB
from abc_quant_analytics.interfaces.analytics_engine_interface import AnalyticsEngine

class Cross(Enum):
    EURUSD = 'wmeur'
    USDJPY = 'wmjpy'
    GBPUSD = 'wmgbp'

class History(Enum):
    T1Y = '1y'
    T2Y = '2y'
    T3Y = '3y'
    T4Y = '4y'
    T5Y = '5y'
    T10Y = '10y'
    T15Y = '15y'
    T20Y = '20y'
    T25Y = '25y'
    T30Y = '30y'

class Window(Enum):
    T1W = '1w'
    T2W = '2w'
    T1M = '1m'
    T2M = '2m'
    T3M = '3m'

class Direction(Enum):
    UP = 'Up'
    DOWN = 'Down'

class BigMoves(AnalyticsEngine):
    def __init__(self,
                 cross: Cross = Cross.EURUSD,
                 end_date: Union[dt.date, None] = None,
                 history: History = History.T10Y,
                 num_moves: int = 10,
                 window: Window = Window.T1M,
                 direction: Direction = Direction.UP,
                 precision: int = 4):
        super().__init__()
        self.cross = cross
        self.end_date = end_date
        self.history = history
        self.num_moves = min(num_moves, 20)  # Ensure maximum of 20 moves
        self.window = window
        self.direction = direction
        self.precision = precision

        # Set end_date to the last available date if not provided
        if self.end_date is None:
            self.end_date = self.get_last_available_date()

    def get_last_available_date(self):
        # Fetch spot data with a wide date range to determine the last available date
        data_series = TSDB.get_data(self.cross.value, start='2000-01-01', end=dt.date.today())
        df = pd.DataFrame(data_series)
        df.index = pd.to_datetime(df.index)
        return df.index.max().date()  # Return the latest date available

    def get_spot_data(self, cross, start, end):
        # Fetch spot data from TSDB
        data_series = TSDB.get_data(cross.value, start=start, end=end)
        df = pd.DataFrame(data_series, columns=['spot'])
        df.index = pd.to_datetime(df.index)  # Ensure datetime index
        df.index.name = 'date'
        return df

    def calculate_resampled_returns(self, df, window_size):
        # Resample data based on window size
        resampled = df['spot'].rolling(window=window_size, min_periods=1).apply(
            lambda x: (x[-1] / x[0] - 1) * 100 if len(x) > 1 else 0, raw=True
        )
        df['rolling_return'] = resampled
        return df

    def find_top_moves(self, df):
        # Rank and select top non-overlapping moves based on specified direction
        df['highlight'] = 0
        sorted_moves = df.sort_values(by='rolling_return', ascending=(self.direction == Direction.DOWN)).dropna(subset=['rolling_return'])
        selected_moves = []
        window_size = self.get_window_size()

        for idx in sorted_moves.index:
            if len(selected_moves) >= self.num_moves:
                break

            # Define the window for this move
            start_idx = idx
            end_idx = start_idx + pd.Timedelta(days=window_size - 1)

            # Check for overlap with existing moves
            if not any(start <= end_idx and end >= start_idx for start, end, _ in selected_moves):
                df.loc[start_idx:end_idx, 'highlight'] = 1
                selected_moves.append((start_idx, end_idx, df.loc[idx, 'rolling_return']))

        return df, selected_moves

    def get_window_size(self):
        # Convert window enum to days
        if self.window == Window.T1W:
            return 5
        elif self.window == Window.T2W:
            return 10
        elif self.window == Window.T1M:
            return 21
        elif self.window == Window.T2M:
            return 42
        elif self.window == Window.T3M:
            return 63
        else:
            raise ValueError("Unsupported window size.")

    def process(self) -> pd.DataFrame:
        # Calculate start date based on history
        years = int(self.history.value[:-1])
        start_date = self.end_date - dt.timedelta(days=years * 365)

        # Fetch spot data
        df = self.get_spot_data(self.cross, start_date, self.end_date)

        # Resample data based on the specified window
        window_size = self.get_window_size()
        df = self.calculate_resampled_returns(df, window_size)

        # Find top moves
        df, _ = self.find_top_moves(df)

        # Return formatted DataFrame
        return df[['spot', 'rolling_return', 'highlight']].round(self.precision)

# Example usage with all parameters explicitly listed for easy modification
big_moves = BigMoves(
    cross=Cross.EURUSD,          # Asset to analyze
    end_date=None,               # Use None for default last available date, or specify a date e.g., dt.date(2023, 12, 31)
    history=History.T10Y,       # Lookback period
    num_moves=10,               # Number of biggest moves to find
    window=Window.T1M,          # Window size for resampling
    direction=Direction.UP,     # Direction for identifying top moves
    precision=4                 # Precision for rounding results
)
result_df = big_moves.process()
print(result_df.head())
